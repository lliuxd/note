# Synchronized详解

> - 定义及主要作用
>
> - 基本用法
>
> - 实现原理
>
> - 锁升级
>
>   引用：[深入分析Synchronized原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/302654066)

## 1、定义及主要作用

定义：synchronized是一个jvm关键字，是解决并发问题的一种常用的手段。

作用：

- 原子性：确保线程互斥的访问同步代码；
- 可见性：保证共享变量的修改能够及时可见。（其实是通过Java内存模型中的“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”来保证的）；
- 有序性：有效解决重排序问题，即“一个unlock操作先行发生（happen-before）于后面对同一个锁的lock操作”；

## 2、基本用法

1. 作用在普通实例方法时，锁 是当前实例对象；
2. 作用在静态方法时，锁 是对象的Class实例（Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁）；
3. 作用在对象实例时（同步代码块），锁 是括号里面的对象实例。

按照功能来区分为**类锁和对象锁**；

注意：synchronized内置锁是一种对象锁，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的，可重入最大的作用是避免死锁。

## 3、实现原理

JVM基于进入和推出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用`monitorenter`和`monitorexit`指令实现的。而方法同步是使用另外一种方式实现的，通过一个方法标志（flag）`ACC_SYNCHRONIZED`来实现的。

### 3.1 同步代码块的实现

**monitorenter 和 monitorexit**

> java对象的布局：对象头，实例数据，对齐填充

每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系又存在多种实现方式，如 monitor 可以与对象一起创建销毁，或当线程试图获取对象锁时自动生成。但当一个 monitor 被某个线程持有后，它便处于锁定状态。

#### 3.1.1monitorenter 

线程执行monitorenter指令时尝试获取monitor的所有权，过程如下

- 如果monitor的进入计数器count为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；
- 如果线程已经占用monitor，只是重新进入，则进入monitor的进入数 +1；
- 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

### 3.1.2 monitorexit

执行monitorexit的线程必须是objectref所对应的monitor的所有者，指令执行时，monitor的进入数 -1 ，如果-1后为0，那线程退出monitor。其他线程就可以尝试获取这个monitor的所有权。

monitorexit指令出现了两次，第一次是正常对出，后面的异常时退出。

> Synchronized的语义底层时通过一个monitor的对象来完成，其实wait/notify 等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出 `java.lang.IllegalMonitorStateException` 的异常的原因

### 3.2同步方法

相对于普通方法，常量池中多了 `ACC_SYNCHRONIZED` 标识符，JVM就是根据该标识符来实现方法的同步的。

当方法调用时，调用指令将会检查方法的`ACC_SYNCHRONIZED`访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。

### 3.3 同步概念

#### 3.3.1 Java 对象头

在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。

![image-20210707232001287](D:\git\note\images\image-20210707232001287.png)

1. 实例数据：存放类的属性数据信息，包括父类的属性信息；
2. 对齐填充：对象起始地址必须是8字节的整数倍。仅仅是为了字节对齐；
3. **对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。**

Synchronized用的锁就是存在Java对象头里的，那么什么是Java对象头呢？Hotspot虚拟机的对象头主要包括两部分数据：**Mark Word（标记字段）、**Class Pointer（类型指针）。其中 Class Pointer是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。 Java对象头具体结构描述如下

![image-20210707232505298](D:\git\note\images\image-20210707232505298.png)

![image-20210713000156408](D:\git\note\images\image-20210713000156408.png)



Java对象头结构组成

Mark Word用于存储对象自身的运行时数据，如：哈希码（HashCode）、GC分代年龄、**锁状态标志**、线程持有的锁、偏向线程 ID、偏向时间戳等。比如锁膨胀就是借助Mark Word的偏向的线程ID 参考：[JAVA锁的膨胀过程和优化(阿里)](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/aspirant/p/11705068.html) 阿里也经常问的问题。

下图是Java对象头 无锁状态下Mark Word部分的存储结构（32位虚拟机）：

![img](D:\git\note\images\v2-a226adc39c9148f67ed2705fd3b97749_720w.png)


Mark Word存储结构

对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，可能变化为存储以下4种数据：



![img](D:\git\note\images\v2-b9ed32856a3110ab2bba8367a79aeb65_720w.jpg)


Mark Word可能存储4种数据

在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：



![img](D:\git\note\images\v2-125f30fa3b2c34c2d29a6987ed4b701a_720w.jpg)


64位Mark Word存储结构

对象头的最后两位存储了锁的标志位，01是初始状态，未加锁，其对象头里存储的是对象本身的哈希码，随着锁级别的不同，对象头里会存储不同的内容。偏向锁存储的是当前占用此对象的线程ID；而轻量级则存储指向线程栈中锁记录的指针。从这里我们可以看到，“锁”这个东西，可能是个锁记录+对象头里的引用指针（判断线程是否拥有锁时将线程的锁记录地址和对象头里的指针地址比较)，也可能是对象头里的线程ID（判断线程是否拥有锁时将线程的ID和对象头里存储的线程ID比较）。



![img](D:\git\note\images\v2-75e1d30161c53145820dd6aed9de09d1_720w.jpg)


HotSpot虚拟机对象头Mark Word

（*判断线程是否拥有锁时，将线程的锁记录地址和对象头里的指针地址比较*）

（*判断线程是否拥有锁时，将线程的ID和对象头里存储的线程ID比较*）

> [深入分析Synchronized原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/302654066) 



## 4、锁等级介绍

### 4.1、偏向锁

当线程持有偏向锁时，分配给线程的jvm虚拟机栈中的lock record 存储的是mark word 的拷贝。

锁对象的对象头中的markword 存储的是线程ID，是否偏向锁，分代年龄等信息。（**主要是线程ID**），*对象头中的 class metadata address 存储的是当前实例的地址的指针*

持有锁的线程不会主动释放，需要有其他线程竞争，竞争成功则替换对象头中的markword 的线程ID。否则就等到一个全局安全点，就升级为轻量锁。

1. 检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；
2. 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；
3. 如果测试线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；
4. 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；
5. 执行同步代码块；

**偏向锁的释放采用了 一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争**。偏向锁的撤销需要 等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：

1. 暂停拥有偏向锁的线程；
2. 判断锁对象是否还处于被锁定状态，否，则恢复到无锁状态（01），以允许其余线程竞争。是，则挂起持有锁的当前线程，并将指向当前线程的锁记录地址的指针放入对象头Mark Word，升级为轻量级锁状态（00），然后恢复持有锁的当前线程，进入轻量级锁的竞争模式；

注意：此处将 当前线程挂起再恢复的过程中并没有发生锁的转移，仍然在当前线程手中，只是穿插了个 “将对象头中的线程ID变更为指向锁记录地址的指针” 这么个事。























