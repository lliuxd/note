# Synchronized详解

> - 定义及主要作用
> - 基本用法
> - 实现原理
>
> - 锁升级

## 1、定义及主要作用

定义：synchronized是一个jvm关键字，是解决并发问题的一种常用的手段。

作用：

- 原子性：确保线程互斥的访问同步代码；
- 可见性：保证共享变量的修改能够及时可见。（其实是通过Java内存模型中的“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”来保证的）；
- 有序性：有效解决重排序问题，即“一个unlock操作先行发生（happen-before）于后面对同一个锁的lock操作”；

## 2、基本用法

1. 作用在普通实例方法时，锁 是当前实例对象；
2. 作用在静态方法时，锁 是对象的Class实例（Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁）；
3. 作用在对象实例时（同步代码块），锁 是括号里面的对象实例。

按照功能来区分为**类锁和对象锁**；

注意：synchronized内置锁是一种对象锁，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的，可重入最大的作用是避免死锁。

## 3、实现原理

JVM基于进入和推出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用`monitorenter`和`monitorexit`指令实现的。而方法同步是使用另外一种方式实现的，通过一个方法标志（flag）`ACC_SYNCHRONIZED`来实现的。

### 3.1 同步代码块的实现

**monitorenter 和 monitorexit**

> java对象的布局：对象头，实例数据，对齐填充

每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系又存在多种实现方式，如 monitor 可以与对象一起创建销毁，或当线程试图获取对象锁时自动生成。但当一个 monitor 被某个线程持有后，它便处于锁定状态。

#### 3.1.1monitorenter 

线程执行monitorenter指令时尝试获取monitor的所有权，过程如下

- 如果monitor的进入计数器count为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；
- 如果线程已经占用monitor，只是重新进入，则进入monitor的进入数 +1；
- 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

### 3.1.2 monitorexit

执行monitorexit的线程必须是objectref所对应的monitor的所有者，指令执行时，monitor的进入数 -1 ，如果-1后为0，那线程退出monitor。其他线程就可以尝试获取这个monitor的所有权。

monitorexit指令出现了两次，第一次是正常对出，后面的异常时退出。

